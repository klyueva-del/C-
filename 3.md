# Циклы
Давайте рассмотрим такую задачу, программе на вход подаются числа, но вы не знаете их количество. Когда вам ввели число `x`, вы должны вывести число `2 * x`. Но если на вход пришло число 0, вы должны завершить работу программы. Тк кол-во чисел заранее не известно, до запуска мы не знаем точно, сколько чисел выводить. Проблему помогут решить циклы.

В C++ выделяют 3 типа циклов: `while`, `for`, `do while`.

__`while`__:

```c++
while (Условие) {
    тело цикла
}
```
Код внутри while будет выполнятся снова и снова, сверху вниз. Каждый раз доходя до конца тела цикла, будет проверка `верно ли` `Условие` внутри `while`, и, если оно верно, код внутри цикла начнет исполняться еще раз.

Посмотрим на такой пример:
```c++
int n = 1;
std::cout << "before while\n";
while (n <= 3) {
    std::cout << "start of cycle\n";
    std::cout << "n in the start " << n << "\n";
    /*
       Тут любые ваши инструкции
    */
    n += 1;
    std::cout << "n in the end " << n << "\n";
    std::cout << "end of cycle\n";
    std::cout << "\n";
}
std::cout << "after while\n";
```
Вывод будет
```
before while
start of cycle
n in the start 1
n in the end 2
end of cycle

start of cycle
n in the start 2
n in the end 3
end of cycle

start of cycle
n in the start 3
n in the end 4
end of cycle

after while
```

Как видно из вывода, пока `n` было <= 3, цикл начинал исполнятся заново. Но когда `n` стал равен `4`, еще раз в тело `while` мы не вошли.

---

Напишем решение той самой задачи из начала:
```c++
int x;
std::cin >> x;
while (x != 0) {
    std::cout << 2 * x << "\n";
    std::cin >> x;
}
```

Можно случайно написать `бесконечный` цикл: 
```c++
std::cout << "before while\n";
while (true) {
}
std::cout << "after while\n"; // Этого никогда не будет
```
Эта программа так и будет крутиться в цикле без конца, такие ситуации лучше не допускать.

---

_Задача1_:

Вводится число `n`. Нужно вывести все числа от `1` до `n`

Решение:
```c++
int n;
std::cin >> n;
int i = 1;
while (i <= n) {
    std::cout << i << "\n";
    ++i;
}

```
`i` пробежит все числа от `1` до `n`, а на `n+1` условие в `while` станет ложным, и цикл завершится.
Также, эту задачу можно решить намного лаконичней, а именно с помощью `for`. Давайте сделаем это

__`for`__:

Когда вы пишите `for`, вы должны ответить на 3 вопроса
1. Что нужно сделать до цикла: как правило, объявление переменных, но в целом любое выражение.
2. Какое условие продолжения цикла.
3. Что нужно сделать после очередной итерации `for`.

Если вы на них ответили, то можно написать такую конструкцию, её общий вид:

```c++
for (Что нужно сделать до цикла; Условие; Что нужно сделать после очередной итерации) {
    Тело цикла
}
```
По правилам, нужно обособлять выражения в круглых скобках с помощью `;`

---

Давайте теперь перепишем _Задачу1_

```c++
int n;
std::cin >> n;
int i = 1; // Это нужно сделать до цикла
while (i <= n) {
    std::cout << i << "\n";
    ++i; // Это нужно сделать после каждой итерации цикла
}
```

Код можно переписать как раз с помощью `for`:

```c++
int n;
std::cin >> n;
for (int i = 1; i <= n; ++i) {
    std::cout << i << "\n";
}
```

_Эти 2 реализации с `while` и c `for` эквивалентны._ Поэтому, когда вы видите написанный `for`, вы можете воспринимать его по аналогии с `while`

---
Посмотрите пример с последовательностью выводов. Заметьте, что `n` увеличивается только после завершения очередной итерации цикла:


```c++
std::cout << "before for\n";
for (int n = 1; n <= 3; ++n) {
    std::cout << "start of cycle\n";
    std::cout << "n in the start " << n << "\n";
    /*
       Тут любые ваши инструкции
    */
    std::cout << "n in the end " << n << "\n";
    std::cout << "end of cycle\n";
    std::cout << "\n";
}
std::cout << "after for\n";
```
Вывод
```
before for
start of cycle
n in the start 1
n in the end 1
end of cycle

start of cycle
n in the start 2
n in the end 2
end of cycle

start of cycle
n in the start 3
n in the end 3
end of cycle

after for
```

---
Рассмотрим несколько примеров

_Пример1_
```c++
int n;
std::cin >> n;
for (int i = 0; i < n; i += 3) {
    std::cout << i << "\n";
}
```
Вывод при `n = 7`
```
0
3
6
```
---
_Пример2_

Здесь мы перебираем степени двойки и выводим их.

Также пример о том, что можно объявлять сразу несколько переменных(`int i = 0, step = 1`), и после очередной итерации цикла выполнять сразу несколько действий(`++i, step *= 2`)
```c++
for (int i = 0, step = 1; step <= 1024; ++i, step *= 2) {
    std::cout << i << " : " << step << "\n";
}
```
Вывод:
```
0 : 1
1 : 2
2 : 4
3 : 8
4 : 16
5 : 32
6 : 64
7 : 128
8 : 256
9 : 512
10 : 1024
```
---
Необязательно заполнять все места в круглых скобках `for`
```c++
int n;
std::cin >> n;
int i = 1;
for (; i <= n; ++i) {
    std::cout << i << "\n";
}
```
```c++
int n;
std::cin >> n;
for (int i = 1; i <= n;) {
    std::cout << i << "\n";
    ++i;
}
```

Можно писать и так, но тогда это никак не отличается от обычного `while`:
```c++
int n;
std::cin >> n;
int i = 1;
for (; i <= n;) { // while (i <= n)
    std::cout << i << "\n";
    ++i;
}
```

И даже так:

```c++
for (;;) { // бесконечный цикл
}
```
Это был пример бесконечного `for`

_Тут мы опускаем понятие бесконечности, просто цикл без явного на то завершения работы_


__`do while`__:

Используется довольно редко. Смысл в том, что сначала выполняется тело цикла, а только потом делается проверка условия продолжения, в то время как `while` и `for` сначала проверяют условие и только потом выполняют код внутри цикла.

```c++
int n = 1;
std::cout << "before do while\n";
do {
    std::cout << "start of cycle\n";
    std::cout << "n in the start " << n << "\n";
    /*
       Тут любые ваши инструкции
    */
    n += 1;
    std::cout << "n in the end " << n << "\n";
    std::cout << "end of cycle\n";
    std::cout << "\n";
} while (n <= 3);
std::cout << "after do while\n";
```
Вывод:
```
before do while
start of cycle
n in the start 1
n in the end 2
end of cycle

start of cycle
n in the start 2
n in the end 3
end of cycle

start of cycle
n in the start 3
n in the end 4
end of cycle

after do while

```
---


__`continue` и `break`__:

Иногда вам хочется прерывать итерацию цикла еще до её завершения. 

--- 

`break`:

```c++
int n = 6;
std::cout << "before for\n";
for (int i = 1; i <= n; ++i) {
	std::cout << "start, i = " << i << "\n";
    if (i == 4) {
        break;
    }
    std::cout << "end\n";
}
std::cout << "after for\n";
```
Вывод:
```
before for
start, i = 1
end
start, i = 2
end
start, i = 3
end
start, i = 4
after for
```
Есть ключевое слово `break`. Его можно писать только в теле цикла. Если программа дойдет до него, то она сразу же целиком выйдет из цикла и продолжит уже выполнять код после цикла. Заметьте, что после строчки `start, i = 4` мы сразу вышли из цикла и дошли до с строчки `after for`.

---

`continue`:

continue работает чуть иначе, см пример:
```c++
int n = 6;
std::cout << "before for\n";
for (int i = 1; i <= n; ++i) {
	std::cout << "start, i = " << i << "\n";
    if (i == 4) {
        continue;
    }
    std::cout << "end\n";
}
std::cout << "after for\n";
```
Вывод:
```
before for
start, i = 1
end
start, i = 2
end
start, i = 3
end
start, i = 4
start, i = 5
end
start, i = 6
end
after for
```
А именно, когда программа доходит до него, она также прерывает итерацию цикла, но не выходит из него полностью, как `break`, а начинает выполнять следующию итерацию.
Поэтому после строчки `start, i = 4` сразу идет `start, i = 5`.

---

__`Вложенные циклы`__:

Внутри тела цикла вы вполне себе можете писать еще один цикл.

---

Пример: Давайте выведем таблицу умножения

```c++
for (int i = 1; i <= 10; ++i) {
    for (int j = 1; j <= 10; ++j) {
        std::cout << i * j << " ";
    }
    std::cout << "\n";
}
```
Вывод
```
1 2 3 4 5 6 7 8 9 10 
2 4 6 8 10 12 14 16 18 20 
3 6 9 12 15 18 21 24 27 30 
4 8 12 16 20 24 28 32 36 40 
5 10 15 20 25 30 35 40 45 50 
6 12 18 24 30 36 42 48 54 60 
7 14 21 28 35 42 49 56 63 70 
8 16 24 32 40 48 56 64 72 80 
9 18 27 36 45 54 63 72 81 90 
10 20 30 40 50 60 70 80 90 100 
```
---

Также никогда не забывайте, что много вложенных циклов могут долго работать, например
```c++
for (int i = 1; i <= 100; ++i) {
    for (int j = 1; j <= 100; ++j) {
        for (int k = 1; k <= 100; ++k) {
            std::cout << i * j * k << " ";
        }
    }
}
```
Каждый цикл перебирает числа от 1 до 100, но тк они вложены, всего на экран будет выведено 1000000 чисел.

---

`continue` и `break` во вложенных циклах выполняют ту же роль. Только помните, что их действие будет распространяться ровно на тот цикл, где они написаны. Если их цикл оказался вложен в какой-то второй цикл, то второй останется нетронутым


```c++
std::cout << "before\n";
for (int i = 1; i <= 3; ++i) {
    std::cout << "big start, i = " << i << "\n";
    for (int j = 1; j <= 3; ++j) {
        std::cout << "small start, j = " << j << "\n";
        if (j >= 2) {
            break;
        }
        std::cout << "small end\n";
    }
    std::cout << "big end\n";
}
std::cout << "after\n";
```
Вывод:
```
before
big start, i = 1
small start, j = 1
small end
small start, j = 2
big end
big start, i = 2
small start, j = 1
small end
small start, j = 2
big end
big start, i = 3
small start, j = 1
small end
small start, j = 2
big end
after
```
Внешний цикл полностью пробежал все свои итерации, в то время как внутренний на `j = 2` постоянно обрывался

# Понятие ассимптотики

Время работы алгоритмов нужно уметь как-то оценивать. Считать время или кол-во тактов процессора не всегда правильно. Поэтому используют такое _понятие_, как _ассимптотика_.

Мы рассмотрим его поверхностно

Рассмотрим 2 цикла:

```c++
const int N1 = 5;
for (int i = 0; i < N1; ++i) {
    std::cout << i << "\n";
}
```

и 

```c++
int N2;
std::cin >> N2;
for (int i = 0; i < N2; ++i) {
    std::cout << i << "\n";
}
```

Сколько работают первый и второй циклы? Первый -- всегда примерно одно и то же время, однако второй работает тем дольше, чем больше переменная $N2$. Причем если переменная $N2$ станет в 2 раза больше, то и цикл будет в ~2 раза дольше работать. Говорят, линейное от $N2$ время работы и обозначают $O(N2)$. Первый же цикл работает за линейное от 1 время (5 = 5 * 1), поэтому пишут $O(1)$.

Итак, когда пишут, что алгоритм/метод работает за $O(1)$, имеют ввиду, что на его выполнение тратится какое-то количество действий, но это количество можно ограничить сверху некой константой. (Т.е. работает не больше, чем несколько действий)

Когда пишут, что алгоритм/метод работает за $O(N)$, имеют ввиду, что на его выполнение тратится какое-то количество действий, и это количество пропорционально переменной $N$.
