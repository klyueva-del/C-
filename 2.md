__Логические операции__
Речь пойдет про операторы сравнения и `&&`, `||`, `!`.



```c++
#include <iostream>

int main() {
    bool a = 5 < 6; // 1
    bool b = 5.5 > 17; // 0
    bool c = 'z' <= 'a'; // 0
    bool d = 'a' >= 'a'; // 1
    std::cout << a << " " << b << " " << c << " " << d << "\n";
    return 0;
}
```

```c++
#include <iostream>

int main() {
    bool a = 'a' == 'a'; // 1
    bool b = 'a' != 'b'; // 1
    bool c = 3 != 3.14; // 0
    bool d = 3 == 3.0; // 1
    std::cout << a << " " << b << " " << c << " " << d << "\n";
    return 0;
}
```

Далее про `&&`, `||`, `!`.


```c++
#include <iostream>

int main() {
    bool t = true;
    bool f = false;
    bool a = f && t; // 0
    bool b = f && f; // 0
    bool c = t && t; // 1

    std::cout << a << " " << b << " " << c << "\n";
    return 0;
}
```

```c++
#include <iostream>

int main() {
    bool t = true;
    bool f = false;
    bool a = f || t; // 1
    bool b = f || f; // 0
    bool c = t || t; // 1

    std::cout << a << " " << b << " " << c << "\n";
    return 0;
}
```

```c++
#include <iostream>

int main() {
    bool t = true;
    bool f = false;
    bool a = !f; // 1
    bool b = !t; // 0

    std::cout << a << " " << b << " " << c << "\n";
    return 0;
}
```


Стоит заметить, что эти операторы предполагают тип `bool`, но можно писать и числовые типы данных
```c++
#include <iostream>

int main() {
    bool a = 5;
    bool b = -6;
    bool c = 3.14;
    std::cout << a << " " << b << " " << c << "\n";
    return 0;
}
```

```c++
#include <iostream>

int main() {
    bool a = !5
    bool b = !(-1);
    bool c = !0;
    std::cout << a << " " << b << " " << c << "\n"; // 0 0 1
    return 0;
}
```
Также про порядок операторов

https://en.cppreference.com/w/cpp/language/operator_precedence

А именно
```c++
#include <iostream>

int main() {
    int x;
    int y;
    std::cin >> x >> y;
    std::cout << x == y; // Так нельзя
    std::cout << (x == y); // Так можно
    std::cout << x && y; // Так нельзя
    std::cout << (x && y); // Так можно
    // и т.д.

    bool f = x == y || x == 5 && y == 6;
    bool g = (x == y || x == 5) && y == 6;
    // f и g -- разные величины
    return 0;
}
```

# Приведение типов

Рассказать, как приводятся типы в тех или иных ситуациях (операторы +, *, (?:))


У всех выражений в языке `C++` компилятор вычисляет тип, т.е. он известен еще на этапе компиляции.


Некоторые типы можно приводить(кастовать) к другим, например `int` -> `long long` или `char` -> `double`.

В языке `C` был один способ явного приведения типов, а именно следующий:

```
Тип1 x;
Тип2 y = (Тип 1) x;
```

Таким способом мы сами задаем, какой тип хотим видеть. Но иногда компилятор делает это за нас.

Например:

Оператор `+` складывает 2 числа только одного типа, при этом в коде мы умеем складывать числа разных типов. Это возможно, тк компилятор приведет все слагаемые к общему типу, который среди них встречается.

```c++
#include <iostream>

int main() {
    std::cout << 'a' + 1;
}
```

Какой тип у `'a' + 1`. У `'a'` -- char, у `1` -- `int`, значит `a` будет преобразовано в `int` и только после этого будет сложение.
Поэтому код выведет `98`. Это пример каста вверх по иерархии типов.

```c++
#include <iostream>

int main() {
    char x = 'a';
    char y = x + 1;
    std::cout << y << "\n";
    std::cout << 'a' + 1 << "\n";
}
```
В этом случае у `x + 1` тип по прежнему `int`, но мы записываем результат в переменную `char`. Будет каст вниз по иерархии типов.
Поэтому в первой строчке будет выведено `b`, во второй `98`

```c++
#include <iostream>

int main() {
    std::cout << (char)('a' + 1) << "\n";
}
```
Здесь явно сказали компилятору кастовать к `char`, поэтому будет `b`

Также стоит отметить, что каст вверх по иерархии типов обычно происходит сначала в `int`, и если необходимо потом уже дальше по иерархии, т.е.

```c++
#include <iostream>

int main() {
    std::cout << typeid('a' + true).name();
}
```
Выведет `i`. (Это значит `int`);

В целом, можно показывать детям результат кастов с помощью `typeid`. Им необязательно пока знать, как он работает, но показать можно.

Рассмотрим еще один пример, где полезно делать приведение типов:

-----

_Задача_:

Дано 3 числа, a, b и mod. a < 10^9, b < 10^9, mod < 10^9

Вывести (a * b) % mod

_Решение_:

Заметим, что все 3 числа, а также результат помещаются в `int`

Кто-то может написать такой код:

```c++
#include <iostream>

int main() {
    int a, b, mod;
    std::cin >> a >> b >> mod;
    int res = (a * b) % mod;
    std::cout << res;
}
```
К сожалению, такой код приведет к ошибке, тк произведение `a * b` < 10 ^ 18, т.е. в `int` может не поместиться, будет переполение(UB). Конечно, можно все `int` заменить на `long long`

```c++
#include <iostream>

int main() {
    long long a, b, mod;
    std::cin >> a >> b >> mod;
    long long res = (a * b) % mod;
    std::cout << res;
}
```
Это будет работать, но представьте, что таких случаев в программе много. Использвать `long long` в 2 раза хуже по памяти, чем `int`, давайте перепишем.

```c++
#include <iostream>

int main() {
    int a, b, mod;
    std::cin >> a >> b >> mod;
    int res = ((long long)a * b) % mod;
    std::cout << res;
}
```

Теперь `a` скастуется в `long long`, тогда и `b` скастуется в `long long`, такой же тип будет и у произведения. Тк к результату мы применяем модуль, то оно поместится в `int` и ошибок не будет.

Также можно написать:
```c++
#include <iostream>

int main() {
    int a, b, mod;
    std::cin >> a >> b >> mod;
    int res = (1ll * a * b) % mod;
    std::cout << res;
}
```
`1ll` - литерал, единица в типе `long long`

`1ull` - в типе `unsigned long long`


-----

Сейчас такой способ называют `C-style-cast` и в промышленном программировании стараются не использовать(но, конечно, не всегда)

Вообще, в `C++` есть 4 варианта каста:
1. static_cast<`Тип`>(`выражение`)
2. reinterpret_cast<`Тип`>(`выражение`)
3. dynamic_cast<`Тип`>(`выражение`)
4. const_cast<`Тип`>(`выражение`)

+можно использовать старый добрый `C-style-cast`

Варианты 2-4 пока рассказывать рано, но 2 будет показан в материалах чуть позже.

Скорее всего, все примеры кастов, которые могут предложить школьники, это по сути `static_cast`

```c++
#include <iostream>

int main() {
    std::cout << static_cast<char>('a' + 1) << "\n";
}
```
```c++
#include <iostream>

int main() {
    int a, b, mod;
    std::cin >> a >> b >> mod;
    int res = (static_cast<long long>(a) * b) % mod;
    std::cout << res;
}
```

Формально `static_cast` говорит сделать преобразование типа еще на этапе компиляции, поэтому и называется `static`



## Тернарный оператор:

_Рассказать, что это такое_

`x = condition ? expr1 : expr2`

Какой тип у `x`? Максимальный из двух типов выражений, если они в целом совместимы.

```c++
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    std::cout << (n > 0 ? 5.5 : 3) / 2;
}
```

У выражения `(n > 0 ? 5.5 : 3)` тип всегда `double`, поэтому деление на 2 будет работать корректно. Проверить можно, подставив `n = 0`

# Оператор запятая

`res = expr1, expr2, ..., exprN`

Все выражения выполнятся слева направо, а результат будет записан в `res`

В `res` будет записан именно результат выполнения `exprN`, такой же и тип всего выражения.

```c++
#include <iostream>

int main() {
    int x;
    double y;
    char z;
    x = 5, y = 2.5, z = 'a'; // Можно писать выражения через запятую
    // Но запятая это оператор, и у него есть возвращаемое значение
    bool f = (true, false);
    std::cout << f << "\n"; // Выведет 0
    std::cout << (x + 6, y + 1.1); // Выведет 3.6
}
```



__Разветвления хода выполнения программы__

Речь пойдет про `if`, `else` и `switch`.

```c++
#include <iostream>

int main() {
    int x;
    std::cin >> x;
    if (x < 0) {
        x *= -1;
    }
    std::cout << x; // Выводит модуль числа
    return 0;
}
```

Рассказать, что в круглых скобках `if` можно писать любое выражение, которое приводимо к `bool` так, как обсуждалось ранее.
```c++
#include <iostream>

int main() {
    int x;
    std::cin >> x;
    if (x & 1) {
        x *= 2;
    }
    std::cout << x; // Нечетные числа умножает на 2
    return 0;
}
```
Более того, фигурные скобки можно не писать, если в теле `if` стоит одно выражение, и нужно писать, если их несколько.
```c++
#include <iostream>

int main() {
    int x;
    std::cin >> x;
    if (x > 0) { // ok
        x *= 2;
    }
    if (x > 0) // ok
        x *= 2;

    if (x == 6) { // ok
        int y;
        std::cin >> y;
        std::cout << 2 * y;
    }
    if (x == 6) // не ok
        int y;
        std::cin >> y;
        std::cout << 2 * y;
    
    return 0;
}
```

Рассказать, про `else` и `else if`

```c++
#include <iostream>

int main() {
    int x;
    std::cin >> x;
    if (x > 0) { // ok
        x *= 2;
    }
    else if (x < 0) { // ok
        x *= 2;
    } else {
        x = 100;
    }
    
    return 0;
}
```
Правила для фигурных скобках такие же

Пример `switch`:

```c++
#include <iostream>

int main() {
    int x;
    std::cin >> x;
    switch (x) {
        case 0:
            std::cout << x;
            break;
        case 1:
            x *= 5;
            std::cout << x;
            break;
        default:
            x = 100;
            break;
    }
    
    return 0;
}
```
Как работает switch.

В скобках указана переменная `x`.

Далее он пробегается по `case` сверху вниз пока не встретит значение, равное этому `x`. Если в очередном `case` он его встретит, то зайдет в блок `case` и будет выполнять указанные там инструкции. В конце, если есть слово `break` то он выйдет из конструкции `switch` целиком, а если оно не указано, то продолжит идти дальше.

Если он дойдет до слова `default`, то обязательно войдет в его конструкцию. При этом default писать не обязательно, и писать можно в любом месте.

Также, если не стоит `break` в конце `case` то это явно намек на ошибку, тк в реальности мало случаев, когда его не ставят(см пример из классной).

_Уточнение_:
1. `x` - должна быть целочисленна, либо явно приводиться к целому типу.
2. Значения в case должны быть константными, т.е. точно не переменные.
3. Все значения в case приводятся к типу `x`
4. В блоке `case` нельзя инициализировать переменные


Далее `switch` с несколькими ошибками
```c++
#include <iostream>

int main() {
    char x;
    std::cin >> x;
    char y = 'b';
    const char z = 'z';
    switch (x) {
        case 3.14: // нельзя приводить double к char
            std::cout << x;
            break;
        case y: // y - не константа
            x = y;
            std::cout << x;
            break;
        case z: // так можно
            x = y;
            std::cout << x;
            break; 
        case z:
            int n = 15; // а так нельзя
            break; 
        default:
            x = 100;
            break;
    }
    
    return 0;
}
```

```c++
#include <iostream>

int main() {
    char x = 5;
    switch (x) {
        case 261: // тут явно UB, тк 261 в char не помещается
            std::cout << 1;
            break;
    }
    
    return 0;
}
```

И еще пример, который компилируется, но отсутствие `break` все ломает

```c++
#include <iostream>

int main() {
    int x = 5;
    switch (x) {
        case 5:
            std::cout << 1;
        default:
            std::cout << 2;
    }
    // Выведет 12
    return 0;
}
```
